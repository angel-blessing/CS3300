<html>
	<title>
		INFO 3300 Project 2
	</title>
	<script src="https://d3js.org/d3.v4.min.js"></script>
	<link rel="stylesheet" href="css/style.css">
	<h1> March Madness </h1>
	<div id = "bracket">
		<h2> March Madness 2017 </h2>
		<svg id = "bracketCircle" height = "1000px" width = "1000px"></svg>
	</div>
	<script>
		var rawScoreData;
	    function parseLine(line){
			return {
				rd0: Number(line["rd1_win"]),
				rd1: Number(line["rd1_win"]),
				rd2: Number(line["rd2_win"]),
				rd3: Number(line["rd3_win"]),
				rd4: Number(line["rd4_win"]),
				rd5: Number(line["rd5_win"]),
				rd6: Number(line["rd6_win"]),
				teamID: Number(line["team_id"]),
				teamName: line["team_name"],
				teamRating: Number(line["team_rating"]),
				teamRegion: line["team_region"],
				teamSeed: Number(line["team_seed"]),
				placement: Number(line["position"])
			};
		}
		var roundData = [];
		var lastVal;
		var reverseData;
	    // Load data for state visualization
		d3.csv("Data/filtered_fivethirtyeight_ncaa_forecasts.csv", parseLine, function(data){
			rawScoreData = data;
			teamData = d3.nest().key(function (d) {
				return d.teamName;
			}).map(rawScoreData);
			for (var i = 0; i < 7; i++){
				var tempRoundData = d3.nest().key(function (d) {
					return d.teamName;
				}).map(rawScoreData);
				roundData.push(tempRoundData);
			}
			reverseData = d3.nest().key(function (d) {
				return d.placement;
			}).map(rawScoreData);
			//createBracket(roundData);
			createCircle(teamData);
		});
		function createSlices(){
			var slices = [];
			for (var roundNum = 0; roundNum < 7; roundNum++){
				for (var gameNum = 1; gameNum <= 64/Math.pow(2, roundNum); gameNum++){
					var currSlice = {
						x: gameNum,
						y: roundNum
					}
					slices.push(currSlice);
				}
			}
			return slices;
		}
		function getArc(){
			var width = 840,
			    height = width,
			    radius = 250,
			    gameScale = d3.scaleLinear().domain([1, 65]).range([0, 2 * Math.PI]),
			    roundScale = d3.scaleLinear().domain([0, 6]).range([radius, 0]),
			    duration = 1000;
			return d3.arc()
			    .startAngle(function(d) {
			    	var xDisplacement = 1 + ((d.x - 1) * Math.pow(2, d.y));
			    	//console.log("b" + xDisplacement);
			    	return Math.max(0, Math.min(2 * Math.PI, gameScale(xDisplacement)));
			    })
			    .endAngle(function(d) {
			    	var xDisplacement =  1 + ((d.x) * Math.pow(2, d.y));
			    	//console.log("e" + xDisplacement);
			    	return Math.max(0, Math.min(2 * Math.PI, gameScale(xDisplacement))); })
			 	.innerRadius(function(d) {
			 		return Math.max(0, roundScale(d.y)); })
			    .outerRadius(function(d) {
			    	return Math.max(0, roundScale(d.y + 1)); });
		}
		function getCentroid(d){
			//mapping this on the array of slices will produce these basic objects
			//that can be passed to a d3.arc function

			var width = 840,
			    height = width,
			    radius = 250,
			    gameScale = d3.scaleLinear().domain([1, 65]).range([0, 2 * Math.PI]),
			    roundScale = d3.scaleLinear().domain([0, 6]).range([radius, 0]),
			    duration = 1000;
			var xDisplacement1 = 1 + ((d.x - 1) * Math.pow(2, d.y));
			var xDisplacement2 =  1 + ((d.x) * Math.pow(2, d.y));
			var arc = d3.arc();

			return arc.centroid({
				innerRadius: Math.max(0, roundScale(d.y)),
				outerRadius: Math.max(0, roundScale(d.y + 1)),
				startAngle: Math.max(0, Math.min(2 * Math.PI, gameScale(xDisplacement1))),
				endAngle: Math.max(0, Math.min(2 * Math.PI, gameScale(xDisplacement2)))
			});
		}
		function getScales(){
			var roundScales = [];
			for (var round = 1; round < 6; round++){
				var tempRange = []
				for (var rangeNum = 1; rangeNum <= 64/Math.pow(2, round); rangeNum++){
					tempRange.push(rangeNum);
				}
				var tempScale = d3.scaleQuantize().domain([1, 64]).range(tempRange);
				roundScales.push(tempScale);
			}
			return roundScales;

		}
		var myScales;
		function createCircle(data){
			var width = 840,
			    height = width,
			    radius = width,
			    duration = 1000;
		    var bracketSvg = d3.select("#bracketCircle")
			    				.append("g")
			    				.attr("transform", "translate(" + width/2 + "," + width/2 + ")");
		    var slices = createSlices();
		    pi = slices;
		    var lastID = "";
		    var roundBins = getScales();
			var paths = bracketSvg.selectAll("path");
			var hueScale = d3.scaleLinear().domain([1,64]).range([0, 360]);
			paths.data(slices).enter()
				.append("path")
				.attr("d", getArc())
				.attr("id", function(d) {
					return "p" + d.x + d.y;
				})
				.on("mousemove", function(d){
					//console.log(d);
					if (lastID != ""){
						bracketSvg.selectAll("#p" + lastID.x + lastID.y)
									.style("fill", function(d){
										return "black";
										});
						for (var i = 1; i < 6; i++){
							var currScale = roundBins[i - 1];
							var currID = "#p" + currScale(lastID.x) + i;
							bracketSvg.selectAll(currID)
								.style("fill", function(d){
									return "black";
							});
						}
					}
					var hueIndex = hueScale(d.x);
					var saturationIndex = reverseData.get(d.x)[0].rd0;
					if (d.y == 0){
						lastID = {x: d.x, y: d.y};
						bracketSvg.selectAll("#p" + d.x + d.y)
									.style("fill", d3.hsl(hueIndex, saturationIndex, 0.5));
						for (var i = 1; i < 6; i++){
							var currScale = roundBins[i - 1];
							var currID = "#p" + currScale(d.x) + i;
							var rdID = "rd" + i;
							saturationIndex = reverseData.get(d.x)[0][rdID];
							bracketSvg.selectAll(currID)
								.style("fill", d3.hsl(hueIndex, saturationIndex, 0.5));
						}
					}
				});

				slices.forEach(function(slice){
					var c = getCentroid(slice);
					bracketSvg.append("text")
					.text("test")
					.attr("x", c[0])
					.attr("y", c[1])
					.attr("text-anchor", "middle");
				});
		}
		/*
		function getArc(roundNum){
			console.log(roundNum);
			var width = 840,
			    height = width,
			    radius = 250,
			    x = d3.scaleLinear().domain([1, (64/Math.pow(2, roundNum))]).range([0, 2 * Math.PI]),
			    y = d3.scaleLinear().domain([0, 6]).range([radius, 0]),
			    duration = 1000;
			return d3.arc()
			    .startAngle(function(d) {
			    	console.log("start");
			    	var xDisplacement = Math.floor(d[0].placement/Math.pow(2, roundNum));
			    	return Math.max(0, Math.min(2 * Math.PI, x(xDisplacement)));
			    })
			    .endAngle(function(d) {
			    	var xDisplacement = Math.floor((d[0].placement + 1)/Math.pow(2, roundNum));
			    	//console.log(xDisplacement);
			    	return Math.max(0, Math.min(2 * Math.PI, x(xDisplacement))); })
			 	.innerRadius(function(d) {
			 		//console.log("round " + roundNum + " " + Math.max(0, y(roundNum)));
			 		return Math.max(0, y(roundNum)); })
			    .outerRadius(function(d) { return Math.max(0, y(roundNum + 1)); });
		}
		// Creats the circular bracket
		function createBracket(data){
			// Potentially 1 to 63?
			var width = 840,
			    height = width,
			    radius = width,
			    x = d3.scaleLinear().domain([1,64]).range([0, 2 * Math.PI]),
			    y = d3.scalePow().exponent(2).domain([1, 6]).range([(2 * Math.PI)/64, radius]),
			    duration = 1000;
		    var bracketSvg = d3.select("#bracketCircle")
		    				.append("g")
		    				.attr("transform", "translate(" + width/2 + "," + width/2 + ")");
			for (var roundNum = 0; roundNum < 7; roundNum++){
				var path = bracketSvg.selectAll("g").data(data[roundNum].values(), function(d) { return d;}).enter()
					.append("path")
					.attr("d", getArc(roundNum))
					.style("fill", function(d){
						//console.log("hi");
						return d3.hsl(360, d[0].placement/100, 1 - d[0].placement/100);
					});
			}
		}
		*/
	</script>
</html>
